/**
 * Created by chenhong on 2020/6/1
 */

/**
 * 防抖与节流
 * 严格算起来，这俩属于性能优化的知识，但是实际上遇到的频率还是挺高的，处理不当或者放任不管就会导致浏览器卡死。所以要尽早掌握。
 *
 * 场景：监听滚动条距离顶部的距离，有一段距离才展示回到顶部的按钮！
 *
 * 防抖（debance）
 * 思路：在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms,然后：
 *  1. 如果在200ms内没有再次触发滚动事件，那么就执行函数
 *  2. 如果在200ms内再次触发事件，那么当前的计时取消，重新开始计时
 * 效果：如果短时间内大量触发同一事件，只会执行一次函数。
 * 实现：既然前面都提到了计时，那实现的关键就在于setTimeout这个函数，由于还需要一个变量来保存计时，考虑维护全局纯净，可以借助闭包来实现：
 *
 */

/**
 * @param fn  需要防抖的函数
 * @param delay  防抖的期限值
 * @returns {Function}
 */
function debance(fn, delay){
    let timer = null;
    return ()=>{
        if(timer){  //进入该分支语句，说明当前正处于一个计时过程中，并且又触发了相同事件，所以要取消当前的计时，重新开始计时
            clearTimeout(timer);
            timer = setTimeout(fn, delay);
        }else{  //进入该分支，说明当前并没有在计时，那么就开始一个计时
            timer = setTimeout(fn, delay);
        }
    };
}

//对上述代码进行 简洁合并 得到如下：
function debance(fn, delay){
    let timer = null;  //借助闭包
    return ()=>{
        if(timer){
            clearTimeout(timer);
        }
        timer = setTimeout(fn, delay);  //简化写法
    };
}

//test
function showTop(){
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    console.log(`滚动条位置 ${scrollTop}`);
}
window.onscroll = debance(showTop, 1000);

/**
 * 经过上述代码，会发现，必须在停止滚动1s之后才会打印出滚动条位置。
 *
 * 到这里，已经把防抖实现了，下面给出定义：
 *     对于短时间内连续触发的事件（上面的滚动事件），防抖的含义就是让某个时间期限内（上面的1秒），事件处理函数只处理一次
 */

//---------------------------debance && throttle分割线---------------------

/**
 * 节流 throttle
 * 继续思考，使用上面的防抖方案来处理问题的结果是：
 *  如果在限定时间段内，不断触发滚动事件（比如某个用户无聊，按住滚动不断地拖来拖去），
 *  只要不停止触发，理论上就永远不会输出当前距离顶部的距离
 *
 * 但是，如果产品同学的期望处理方案是：即使用户不断拖动滚动条，也能在某个时间间隔之后给出反馈呢？
 *
 * 其实很简单：
 *  我们可以设计一种类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活（类似于技能冷却时间）
 *
 * 效果：
 *  如果短时间内大量触发同一事件，那么在函数执行一次后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。
 *
 * 实现：
 *  这里借助setTimeout来做一个简单的实现，加上一个状态为valid 来表示当前函数是否处于工作状态：
 */
function throttle(fn, delay){
    var valid = true;
    return ()=>{
        if(!valid){  //休息时间，暂不接客
            return false;
        }
        //工作时间，执行函数，并在间隔期限内将状态为设为无效
        valid = false;
        setTimeout(()=>{
            fn();
            valid = true;
        }, delay);
    }
}

/**
 * 请注意：
 *      节流函数不止上面这一种实现方式，例如，完全可以不借助setTimeout, 可以将状态位设为时间戳，然后利用时间戳的差值 是否大于 间隔时间来做判定
 *      也可以直接将setTimeout的返回的标记当做判断条件--如果存在表示还在冷却，并且在执行fn之后消除定时器表示激活，原理第一样
 */

//test
function showTop(){
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    console.log(`滚动条位置 ${scrollTop}`);
}

window.onscroll = throttle(showTop, 1000);

/**
 * 以上代码的运行结果：
 *  如果一直拖动滚动条，那么会以1秒的时间间隔，持续输出当前位置和顶部的距离
 */

//----------------------------------应用场景----------------------
/**
 * 讲完了两个技巧，下面介绍平时开发中遇到的场景：
 * 1. 搜索框input事件， 例如要支持输入实时搜索，可以使用节流方案，（间隔一段时间就必须查询相关内容），
 *    或者实现输入间隔大于某个值（如500ms）,就当做用户输入完成，然后开始搜索，具体使用哪种方案，要看业务需求
 * 2. 页面resize事件，常见于需要做页面适配的时候。需要根据最终呈现的页面情况进行dom渲染（这种情形一般是适用防抖，因为只需要判断最后一次的变化情况）
 */

//----------------------------------思考总结----------------------
/**
 * 上述的showTop的例子很简单，无需考虑作用域和参数传递，所以连apply也没用到，
 * 实际上，肯定是需要考虑传递arguments 以及 上下文环境
 */


